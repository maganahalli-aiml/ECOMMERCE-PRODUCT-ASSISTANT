name: CI/CD to EKS (v2)

on:
  push:
    branches:
      - master   # Updated to use master branch
  workflow_dispatch: # allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history to avoid caching issues

      # Debug step to verify we have the correct version
      - name: Verify workflow version
        run: |
          echo "=== WORKFLOW VERSION DEBUG ==="
          echo "Current commit hash:"
          git rev-parse HEAD
          echo "Last commit message:"
          git log -1 --pretty=format:"%s"
          echo "Current timestamp: $(date)"
          echo "=== END DEBUG ==="

      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Check if EKS Cluster exists
      - name: Check if EKS Cluster exists
        run: |
          if ! aws eks describe-cluster --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}; then
            echo "EKS Cluster not found! Run infra.yml workflow first."
            exit 1
          fi

      - name: Deploy CloudFormation Stack
        run: |
          echo "Deploying CloudFormation stack..."
          aws cloudformation deploy \
            --stack-name product-assistant-cluster \
            --template-file infra/eks-with-ecr.yaml \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --region ${{ secrets.AWS_REGION }} \
            --no-fail-on-empty-changeset
          echo "CloudFormation stack deployment completed"

      # Login to ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: 'true'

      # Build, tag and push docker image to ECR
      - name: Build and Push Docker image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: product-assistant
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          echo "Building Docker image..."
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG -t $REGISTRY/$REPOSITORY:latest .
          echo "Pushing Docker image to ECR..."
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:latest
          echo "Docker image pushed successfully: $REGISTRY/$REPOSITORY:$IMAGE_TAG"

      # Setup kubectl
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
      
      # Ensure AWS CLI is installed
      - name: Install AWS CLI
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install --update
          aws --version
    
      - name: Print Env Vars
        run: |
          echo "Region: ${{ secrets.AWS_REGION }}"
          echo "Cluster: ${{ secrets.EKS_CLUSTER_NAME }}"

      # Update kubeconfig for EKS
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} --debug

      # Debug: Show kubeconfig file
      - name: Show kubeconfig
        run: |
          ls -la ~/.kube || true
          cat ~/.kube/config || true

      # âœ… NEW APPROACH: Force delete and recreate secret
      - name: Force Update Kubernetes secret for API keys
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          ASTRA_DB_API_ENDPOINT: ${{ secrets.ASTRA_DB_API_ENDPOINT }}
          ASTRA_DB_APPLICATION_TOKEN: ${{ secrets.ASTRA_DB_APPLICATION_TOKEN }}
          ASTRA_DB_KEYSPACE: ${{ secrets.ASTRA_DB_KEYSPACE }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
        run: |
          echo "=== MANAGING KUBERNETES SECRET ==="
          echo "Timestamp: $(date)"
          
          # First, delete the existing secret (ignore if it doesn't exist)
          echo "Deleting existing secret..."
          kubectl delete secret product-assistant-secrets --ignore-not-found=true
          echo "Secret deletion completed (or didn't exist)"
          
          # Wait a moment to ensure deletion is complete
          sleep 2
          
          # Create the secret fresh
          echo "Creating new secret..."
          kubectl create secret generic product-assistant-secrets \
            --from-literal=GROQ_API_KEY="${GROQ_API_KEY}" \
            --from-literal=ASTRA_DB_API_ENDPOINT="${ASTRA_DB_API_ENDPOINT}" \
            --from-literal=ASTRA_DB_APPLICATION_TOKEN="${ASTRA_DB_APPLICATION_TOKEN}" \
            --from-literal=ASTRA_DB_KEYSPACE="${ASTRA_DB_KEYSPACE}" \
            --from-literal=GOOGLE_API_KEY="${GOOGLE_API_KEY}"
          
          echo "Secret created successfully!"
          
          # Verify the secret exists
          echo "Verifying secret creation..."
          kubectl get secret product-assistant-secrets -o yaml
          echo "=== SECRET MANAGEMENT COMPLETED ==="

      # Deploy to EKS using kubectl
      - name: Deploy to EKS -(Apply Kubernetes manifests)
        run: |
          kubectl apply -f k8/deployment.yaml
          kubectl apply -f k8/service.yaml
      
      - name: Patch deployment with new image tag
        env:
          REGISTRY: ${{ secrets.ECR_REGISTRY }}
          REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          kubectl set image deployment/product-assistant product-assistant=$REGISTRY/$REPOSITORY:$IMAGE_TAG
          echo "Deployment image updated to $REGISTRY/$REPOSITORY:$IMAGE_TAG"

      # Verify rollout
      - name: Verify Deployment
        run: |
          set -e
          if ! kubectl rollout status deployment/product-assistant --timeout=120s; then
            echo "Rollout failed, collecting debug info..."
            kubectl describe deployment product-assistant || true
            kubectl get pods -o wide || true
            for pod in $(kubectl get pods -l app=product-assistant -o jsonpath='{.items[*].metadata.name}'); do
              echo "--- Logs for pod: $pod ---"
              kubectl logs $pod --all-containers --tail=100 || true
            done
            exit 1
          fi
          echo "Rollout successful!"

      # Show service details
      - name: Get Service Info
        run: kubectl get svc product-assistant-service -o wide